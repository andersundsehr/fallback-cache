<?php

declare(strict_types=1);

namespace Weakbit\FallbackCache\Cache;

use Psr\EventDispatcher\EventDispatcherInterface;
use Psr\Log\LoggerAwareInterface;
use Psr\Log\LoggerAwareTrait;
use Throwable;
use TYPO3\CMS\Core\Cache\Exception\DuplicateIdentifierException;
use TYPO3\CMS\Core\Cache\Exception\InvalidBackendException;
use TYPO3\CMS\Core\Cache\Exception\InvalidCacheException;
use TYPO3\CMS\Core\Cache\Exception\NoSuchCacheException;
use TYPO3\CMS\Core\Cache\Frontend\PhpFrontend;
use TYPO3\CMS\Core\Utility\GeneralUtility;
use TYPO3\CMS\Extbase\Utility\DebuggerUtility;
use Weakbit\FallbackCache\Enum\StatusEnum;
use Weakbit\FallbackCache\Event\CacheStatusEvent;
use Weakbit\FallbackCache\Exception\RecursiveFallbackCacheException;
use Weakbit\LuceneCache\Cache\Frontend\VariableFrontend;

class CacheManager extends \TYPO3\CMS\Core\Cache\CacheManager implements LoggerAwareInterface
{
    use LoggerAwareTrait;

    protected array $fallbacks = [];

    protected ?\TYPO3\CMS\Core\Cache\Frontend\VariableFrontend $cache = null;

    protected array $status = [];

    protected array $seen = [];

    public function setCacheConfigurations(array $cacheConfigurations): void
    {
        parent::setCacheConfigurations($cacheConfigurations); // TODO: Change the autogenerated stub
        try {
            $cache = $this->getCache('weakbit__fallback-cache');
            if (!$cache instanceof \TYPO3\CMS\Core\Cache\Frontend\VariableFrontend) {
                throw new InvalidCacheException('Cache must be an instance of VariableFrontend');
            }
            $this->cache = $cache;
            $status = $cache->get('status');
            if (is_array($status)) {
                $this->status = $status;
            }
        } catch (Throwable $e) {
            $this->logger?->error($e->getMessage());
        }
    }

    public function addCacheStatus(string $identifier, StatusEnum $status): void
    {
        // do not overwrite the highest state
        if (isset($this->status[$identifier]) && $this->status[$identifier] === StatusEnum::RED) {
            return;
        }
        // TODO war und ist yellow, nichtnur status sondern auch noch counter speichern und bei ueberschreitung rot setzen (auch per event, hier dann return) sodass ein logging und andre mechanismen passen
        $this->status[$identifier] = $status;
        $this->cache?->set('status', $this->status);
    }

    protected function createCache($identifier): void
    {
        if ($this->isStatusRed($identifier)) {
            $this->createCacheWithFallback($identifier);
            return;
        }
        try {
            // pages_fallback
            #if ($identifier === 'pages') {
               # throw new \RuntimeException('test');
            #}
            /*
            if ($identifier === 'pages_fallback') {
                throw new \RuntimeException('test');
            }
            if ($identifier === 'pages_fallback_fallback') {
                throw new \RuntimeException('test');
            }
            */
            parent::createCache($identifier);
        } catch (InvalidCacheException|InvalidBackendException|RecursiveFallbackCacheException $exception) {
            throw $exception;
        } catch (Throwable $throwable) {
            $eventDispatcher = GeneralUtility::makeInstance(EventDispatcherInterface::class);
            assert($eventDispatcher instanceof EventDispatcherInterface);
            $eventDispatcher->dispatch(new CacheStatusEvent(StatusEnum::RED, $identifier));
            $this->createCacheWithFallback($identifier);
        }
        // TODO das fallback muss das selbe frontend haben, instanceof maessig, sonst sagen wir hier auch adee
        // TODO if we have at least one status red, display a clear status flash in backend
    }

    private function getFallbackCacheOf(string $identifier): ?string
    {
        $fallback = $this->cacheConfigurations[$identifier]['fallback'] ?? null;

        // no endless loop
        if ($identifier === $fallback || $this->isSeen($fallback)) {
            throw new RecursiveFallbackCacheException();
        }
        if (null === $fallback) {
            return null;
        }
        $this->registerFallback($identifier, $fallback);
        return $fallback;
    }

    /**;
     * registers all fallback caches in the chain to prevent endess loops
     */
    private function isSeen($fallback): bool
    {
        return in_array($fallback, $this->seen, true);
    }

    private function isStatusRed(string $identifier): bool
    {
        if (!isset($this->status[$identifier])) {
            return false;
        }
        return match ($this->status[$identifier]) {
            StatusEnum::RED => true,
            default => false
        };
    }

    public function getCache($identifier): \TYPO3\CMS\Core\Cache\Frontend\FrontendInterface
    {
        $cache = parent::getCache($identifier);
        if ($cache) {
            return $cache;
        }
       ;

        if (isset($this->fallbacks[$identifier])) {
            $cache = $this->getCache($this->fallbacks[$identifier]);
        }
        if (null === $cache) {
            $chain = $this->getBreadcrumb($identifier);
            $chainString = implode('->', array_reverse($chain));
            throw new \RuntimeException('Could not instanciate cache using the chain ' . $chainString);
        }
        return $cache;
    }

    private function getBreadcrumb(string $identifier, array $breadcrumb = []): array
    {
        foreach ($this->fallbacks as $origin => $fallback) {
            if ($fallback === $identifier) {
                $breadcrumb[] = $fallback;
                return $this->getBreadcrumb($origin, $breadcrumb);
            }
        }
        $breadcrumb[] = $identifier;
        return $breadcrumb;
    }

    private function registerFallback(string $identifier, mixed $fallback): void
    {
        $this->fallbacks[$identifier] = $fallback;
    }

    protected array $breadcrumb = [];

    /**
     * @throws DuplicateIdentifierException
     * @throws InvalidBackendException
     * @throws InvalidCacheException
     */
    private function createCacheWithFallback(string $identifier): void
    {
        $fallback = $this->getFallbackCacheOf($identifier);
        if (!$fallback) {
            return;
        }
        if (!$this->hasCache($fallback)) {
            $this->createCache($fallback);
        }
    }
}
